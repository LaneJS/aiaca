# API Service (Spring Boot)

Spring Boot backend for the AACA platform. Endpoints are versioned under `/api/v1` and secured with JWT bearer tokens. Auth-only routes require an `Authorization: Bearer <token>` header.

## Database & migrations

- **Tooling:** Flyway is available with migration scripts under `src/main/resources/db/migration`. The H2 profile for tests runs without Flyway by default; enable Flyway when pointing at Postgres.
- **Schema overview:**
  - `users` ↔ `sites` (1:M) with uniqueness on `user_id + base_url` to avoid duplicate entries.
  - `sites` ↔ `scans` (1:M) with indexes on `site_id` and `status` for dashboards.
  - `scans` ↔ `scan_issues` (1:M) and `scan_issues` ↔ `ai_suggestions` (1:M) to attach suggested fixes per issue.
  - `api_keys` (per user) and `embed_keys` (per site, unique) capture authentication material separately from user auth.
- **Running migrations locally:**
  - Ensure Postgres is available (e.g., via `docker-compose up postgres`).
  - Run `./gradlew flywayInfo` or start the app with `SPRING_FLYWAY_ENABLED=true` to apply migrations.
  - For dev seed data (sample user + site), start with `SPRING_PROFILES_ACTIVE=local` so Flyway also loads `db/seed/local`.
- **Naming conventions:** snake_case table/column names, UUID primary keys generated by Hibernate, and `_at` timestamps stored as UTC `timestamptz`.

## Getting Started
- Install Node/Angular deps at root for Nx tooling: `npm install`
- Build the service: `npx nx build api`
- Run tests: `npx nx test api` or `./gradlew test`
- Launch the app locally: `npx nx serve api`
- If the Gradle wrapper JAR is missing (binary files are ignored), regenerate it with a locally installed Gradle: `gradle wrapper --gradle-version 8.7`.

H2 is enabled for local dev/tests by default; configure Postgres via standard Spring datasource properties when running against a real database.

## Endpoints

### Auth
- `POST /api/v1/auth/register` – body `{ "email": "user@example.com", "password": "Secret123" }`
- `POST /api/v1/auth/login` – same body as register.
- `POST /api/v1/auth/logout` – send current bearer token in `Authorization` header; token is blacklisted server-side. Invalid/expired tokens are safely ignored.

Successful auth responses:
```json
{
  "userId": "<uuid>",
  "email": "user@example.com",
  "token": "<jwt>"
}
```

### Sites
- `POST /api/v1/sites` – create a site. Body `{ "name": "My Shop", "url": "https://shop.test" }`
- `GET /api/v1/sites` – list sites for the current user.
- `GET /api/v1/sites/{id}` – site details including embed key.

### Scans (authenticated)
- `POST /api/v1/sites/{id}/scans` – body `{ "pageUrl": "https://site/page" }` queues a scan and returns a stubbed completed result for MVP.
- `GET /api/v1/sites/{id}/scans` – list scan summaries.
- `GET /api/v1/scans/{id}` – scan detail with issues and AI suggestion placeholders.

### Public Scan (unauthenticated)
- `POST /api/v1/public/scans` – body `{ "url": "https://example.com" }`
  - Returns limited issues and score.
  - Rate limited in-memory to 5 requests/minute per IP.

### Embed Config
- `GET /api/v1/sites/{id}/embed-config`
  - Provide `X-Embed-Key` header for anonymous embed script access, or an auth token if calling from the dashboard.
  - Response:
```json
{
  "siteId": "<uuid>",
  "embedKey": "<uuid>",
  "autoFixes": ["alt_text", "focus_outline"],
  "enableSkipLink": true
}
```

## Error handling & logging
- Validation errors return HTTP 400 with `{ "code": "validation_failed", "errors": { "field": "message" } }`.
- Not found resources return HTTP 404 with code `not_found`.
- Tokens are hashed using BCrypt; JWT secret/expiration configurable via `security.jwt.*` properties.
- Rate limiting and logout token blacklist use in-memory stores appropriate for MVP; migrate to Redis for production.

## Notes
- Endpoints are namespaced under `/api/v1` to allow future versioned contracts.
- Entities use cascading deletes for site → scans → issues to keep demo data clean.
