# API Service (Spring Boot)

Spring Boot backend for the AACA platform. Endpoints are versioned under `/api/v1` and secured with JWT bearer tokens. Auth-only routes require an `Authorization: Bearer <token>` header.

## Database & migrations

- **Tooling:** Flyway migrations live under `src/main/resources/db/migration`. H2 is enabled by default for local dev/tests; point the datasource at Postgres and set `SPRING_FLYWAY_ENABLED=true` to run migrations against a real database.
- **Schema overview:**
  - `users` ↔ `sites` (1:M) with uniqueness on `user_id + base_url` to avoid duplicate entries.
  - `sites` ↔ `scans` (1:M) with indexes on `site_id` and `status` for dashboards.
  - `scans` ↔ `scan_issues` (1:M) and `scan_issues` ↔ `ai_suggestions` (1:M) to attach suggested fixes per issue.
  - `api_keys` (per user) and `embed_keys` (per site, unique) capture authentication material separately from user auth.
- **Running migrations locally:**
  - Ensure Postgres is available (e.g., via `docker-compose up postgres` or pointing to an existing DB).
  - Run `SPRING_FLYWAY_ENABLED=true ./gradlew flywayInfo` or start the app with the env var set so Flyway applies the pending scripts.
  - For dev seed data (sample user + site), start with `SPRING_PROFILES_ACTIVE=local` so Flyway also loads `db/seed/local`.
- **Naming conventions:** snake_case table/column names, UUID primary keys generated by Hibernate, and `_at` timestamps stored as UTC `timestamptz`.

## Getting Started
- Install root dependencies for Nx tooling: `npm install`
- Build the service: `npx nx build api`
- Run tests (H2 + mocked services): `npx nx test api` or `./gradlew test`
- Launch the app locally (defaults to H2): `npx nx serve api`
- Use the repo wrapper script (`./gradlew …`) for all commands so you pick up the pinned Gradle version (8.x). If `gradle/wrapper/gradle-wrapper.jar` is somehow absent, install Gradle 8.7+ and run `gradle wrapper --gradle-version 8.7` once to rehydrate it—older system Gradle versions will fail with `TaskContainer.named(...)` errors during configuration.

Configure Postgres access by exporting the `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, and related vars plus `SPRING_FLYWAY_ENABLED=true` before starting the app.

### Service integration

The API calls downstream services via `WebClient` with correlation IDs propagated in the `X-Request-Id` header:

- **Scanner** – `POST ${SCANNER_SERVICE_URL:/scan}`. Defaults to `http://scanner:4001/scan` in Docker and `http://localhost:4001/scan` for local runs.
- **AI orchestrator** – `POST ${AI_ORCHESTRATOR_SERVICE_URL:/suggest-fixes}`. Defaults to `http://ai-orchestrator:4002/suggest-fixes`.
- **Timeouts** – configurable via `EXTERNAL_HTTP_TIMEOUT_MS` (default 8000ms).
- **Stub mode** – set `AI_ORCHESTRATOR_USE_STUB=true` to force suggestions from the orchestrator stub provider while exercising real scanner responses.

## Endpoints

### Auth
- `POST /api/v1/auth/register` – body `{ "email": "user@example.com", "password": "Secret123" }`
- `POST /api/v1/auth/login` – same body as register.
- `POST /api/v1/auth/logout` – bearer token logout; invalid/expired tokens are safely ignored. (MVP stores blacklisted tokens in memory.)

Successful auth responses:

```json
{
  "userId": "<uuid>",
  "email": "user@example.com",
  "token": "<jwt>"
}
```

### Sites
- `POST /api/v1/sites` – create a site. Body `{ "name": "My Shop", "url": "https://shop.test" }`
- `GET /api/v1/sites` – list sites for the current user.
- `GET /api/v1/sites/{id}` – site details including embed key.

### Scans (authenticated)
- `POST /api/v1/sites/{id}/scans` – body `{ "pageUrl": "https://site/page" }` triggers a real scan via `services/scanner` and persists results + AI suggestions.
- `GET /api/v1/sites/{id}/scans` – list scan summaries.
- `GET /api/v1/scans/{id}` – scan detail with issues and AI suggestions (first suggestion surfaced per issue in the API DTO).

### Public Scan (unauthenticated)
- `POST /api/v1/public/scans` – body `{ "url": "https://example.com" }`
  - Returns limited issues and score, populated directly from the scanner service.
  - Rate limited in-memory to 5 requests/minute per IP (override with `security.public-scan.rate-limit.max-requests` and `security.public-scan.rate-limit.window-ms`).
  - URLs are normalized to http/https and have fragments removed before scans run.

### Embed Config
- `GET /api/v1/sites/{id}/embed-config`
  - Provide `X-Embed-Key` header for anonymous embed script access, or an auth token if calling from the dashboard.
  - Response:

```json
{
  "siteId": "<uuid>",
  "embedKey": "<uuid>",
  "autoFixes": ["alt_text", "focus_outline"],
  "enableSkipLink": true
}
```

## Error handling & logging
- Validation errors return HTTP 400 with `{ "code": "validation_failed", "errors": { "field": "message" } }`.
- Not found resources return HTTP 404 with code `not_found`.
- Tokens are hashed using BCrypt; JWT secret/expiration configurable via `security.jwt.*` properties.
- Rate limiting and logout token blacklist use in-memory stores appropriate for MVP; migrate to Redis for production.

## Notes
- Endpoints are namespaced under `/api/v1` to allow future versioned contracts.
- Entities use cascading deletes for site → scans → issues to keep demo data clean.
- Add a `/health` endpoint plus more detailed observability hooks as part of the infra backlog.
